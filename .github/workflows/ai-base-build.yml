name: Build AI Base Layer Images

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'apps/ai-inference/**'
      - '.github/workflows/ai-base-build.yml'
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]
    paths:
      - 'apps/ai-inference/**'
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/ai-base

jobs:
  # Build matrix for all variants
  build-variants:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        variant:
          - name: vulkan
            gpu_variant: vulkan
            description: "Universal GPU support via Vulkan"
            size_target: "4GB"
          - name: nvidia
            gpu_variant: nvidia
            description: "NVIDIA GPU optimized with CUDA"
            size_target: "6GB"
          - name: rocm
            gpu_variant: rocm
            description: "AMD GPU optimized with ROCm"
            size_target: "9GB"
          - name: latest
            gpu_variant: all
            description: "Multi-backend with auto-detection"
            size_target: "15GB"

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata (tags, labels)
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        flavor: |
          latest=${{ matrix.variant.name == 'latest' }}
          suffix=-${{ matrix.variant.name }},onlatest=false
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=semver,pattern={{major}}
          type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' && matrix.variant.name == 'latest' }}
          type=raw,value=${{ matrix.variant.name }},enable=true
          type=sha,prefix=${{ matrix.variant.name }}-,suffix=-{{date 'YYYYMMDD'}},format=short

    - name: Build and push Docker image (${{ matrix.variant.name }})
      id: build
      uses: docker/build-push-action@v5
      with:
        context: ./apps/ai-inference
        file: ./apps/ai-inference/Dockerfile
        platforms: linux/amd64,linux/arm64
        push: ${{ github.event_name != 'pull_request' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: |
          ${{ steps.meta.outputs.labels }}
          variant=${{ matrix.variant.name }}
          gpu_backend=${{ matrix.variant.gpu_variant }}
          description=${{ matrix.variant.description }}
        cache-from: type=gha,scope=ai-base-${{ matrix.variant.name }}
        cache-to: type=gha,mode=max,scope=ai-base-${{ matrix.variant.name }}
        build-args: |
          GPU_VARIANT=${{ matrix.variant.gpu_variant }}
          BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
          VCS_REF=${{ github.sha }}
          VERSION=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.version'] }}

    - name: Image size check
      if: github.event_name == 'pull_request'
      run: |
        echo "Checking image size for ${{ matrix.variant.name }} variant"
        echo "Target size: ${{ matrix.variant.size_target }}"
        # Note: Actual size check would require pulling the image
        # For PR builds, we're just documenting the target

  # Security scanning of built images
  security-scan:
    needs: build-variants
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request'
    strategy:
      fail-fast: false
      matrix:
        variant: [vulkan, nvidia, rocm, latest]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ matrix.variant }}
        format: 'sarif'
        output: 'trivy-results-${{ matrix.variant }}.sarif'
        severity: 'CRITICAL,HIGH'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-results-${{ matrix.variant }}.sarif'
        category: ai-base-${{ matrix.variant }}

  # Test built images
  test-variants:
    needs: build-variants
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request'
    strategy:
      fail-fast: false
      matrix:
        variant: [vulkan, nvidia, rocm, latest]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Pull image
      run: |
        docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ matrix.variant }}

    - name: Test image - GPU info
      run: |
        docker run --rm \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ matrix.variant }} \
          /usr/local/bin/gpu-info

    - name: Test image - Detect GPU
      run: |
        docker run --rm \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ matrix.variant }} \
          /usr/local/bin/detect-gpu

    - name: Test image - Check engines
      run: |
        docker run --rm \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ matrix.variant }} \
          bash -c "
            echo 'Checking Ollama...'
            ollama --version || echo 'Ollama check complete'

            echo 'Checking llama.cpp...'
            ls -la /opt/ai-base/bin/llama-* || echo 'llama.cpp binaries listed'

            echo 'Checking Python...'
            python3 --version

            echo 'All checks passed'
          "

    - name: Test image - Variant environment
      run: |
        docker run --rm \
          -e GPU_BACKEND=vulkan \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ matrix.variant }} \
          bash -c "env | grep -E '(GPU_|VULKAN_|CUDA_|ROCM_|OLLAMA_)' || true"

  # Create release for tagged builds
  release:
    needs: [build-variants, security-scan, test-variants]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Generate changelog
      id: changelog
      run: |
        echo "## AI Base Layer Release" > CHANGELOG.md
        echo "" >> CHANGELOG.md
        echo "### Docker Images" >> CHANGELOG.md
        echo "" >> CHANGELOG.md
        echo "**Variants:**" >> CHANGELOG.md
        echo "- \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:vulkan\` - Universal GPU support (Vulkan)" >> CHANGELOG.md
        echo "- \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:nvidia\` - NVIDIA optimized (CUDA)" >> CHANGELOG.md
        echo "- \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:rocm\` - AMD optimized (ROCm)" >> CHANGELOG.md
        echo "- \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest\` - Multi-backend with auto-detection" >> CHANGELOG.md
        echo "" >> CHANGELOG.md
        echo "**Inference Engines:**" >> CHANGELOG.md
        echo "- Ollama (with Vulkan support)" >> CHANGELOG.md
        echo "- llama.cpp (all backends)" >> CHANGELOG.md
        echo "- llm-d (D language implementation)" >> CHANGELOG.md
        echo "- EXO (distributed inference)" >> CHANGELOG.md
        echo "" >> CHANGELOG.md

        # Get previous tag
        PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

        if [ -n "$PREVIOUS_TAG" ]; then
          echo "### What's Changed" >> CHANGELOG.md
          git log --pretty=format:"* %s (%h)" "$PREVIOUS_TAG"..HEAD | grep -i "ai-base\|inference\|gpu" >> CHANGELOG.md || echo "* Various improvements" >> CHANGELOG.md
        fi

        echo "" >> CHANGELOG.md
        echo "**Usage Example:**" >> CHANGELOG.md
        echo '```dockerfile' >> CHANGELOG.md
        echo "FROM ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:vulkan" >> CHANGELOG.md
        echo "# Your application code here" >> CHANGELOG.md
        echo '```' >> CHANGELOG.md

    - name: Create Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref_name }}
        release_name: AI Base Layer ${{ github.ref_name }}
        body_path: CHANGELOG.md
        draft: false
        prerelease: ${{ contains(github.ref_name, '-rc') || contains(github.ref_name, '-beta') || contains(github.ref_name, '-alpha') }}

  # Cleanup old untagged images
  cleanup:
    needs: [build-variants]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
    - name: Delete old untagged images
      uses: actions/github-script@v7
      continue-on-error: true
      with:
        script: |
          const variants = ['vulkan', 'nvidia', 'rocm', 'latest'];

          for (const variant of variants) {
            try {
              const packageName = `ai-base-${variant}`;
              const response = await github.rest.packages.getAllPackageVersionsForPackageOwnedByOrg({
                package_type: 'container',
                package_name: packageName,
                org: context.repo.owner,
                per_page: 100
              });

              // Keep last 10 versions, delete older untagged
              const versions = response.data
                .filter(v => v.metadata.container.tags.length === 0)
                .slice(10);

              for (const version of versions) {
                console.log(`Deleting old untagged version: ${version.id} for ${variant}`);
                await github.rest.packages.deletePackageVersionForOrg({
                  package_type: 'container',
                  package_name: packageName,
                  org: context.repo.owner,
                  package_version_id: version.id,
                });
              }
            } catch (error) {
              console.log(`Error cleaning up ${variant}: ${error.message}`);
            }
          }
